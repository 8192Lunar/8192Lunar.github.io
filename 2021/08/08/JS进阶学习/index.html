<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一、前言1.1 JavaScript的组成 JavaScript 由 ECMAScript（JavaScript语法）、DOM（页面文档对象模型）和BOM（浏览器对象模型）组成，Web APIs是JS的应用，主要是指DOM和BOM 1.2 API API（应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制">
<meta property="og:type" content="article">
<meta property="og:title" content="JS进阶学习">
<meta property="og:url" content="http://yoursite.com/2021/08/08/JS进阶学习/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、前言1.1 JavaScript的组成 JavaScript 由 ECMAScript（JavaScript语法）、DOM（页面文档对象模型）和BOM（浏览器对象模型）组成，Web APIs是JS的应用，主要是指DOM和BOM 1.2 API API（应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-08-08T10:07:57.966Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS进阶学习">
<meta name="twitter:description" content="一、前言1.1 JavaScript的组成 JavaScript 由 ECMAScript（JavaScript语法）、DOM（页面文档对象模型）和BOM（浏览器对象模型）组成，Web APIs是JS的应用，主要是指DOM和BOM 1.2 API API（应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制">





  
  
  <link rel="canonical" href="http://yoursite.com/2021/08/08/JS进阶学习/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JS进阶学习 | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/08/JS进阶学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JS进阶学习

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2021-08-08 18:05:59 / Geändert am: 18:07:57" itemprop="dateCreated datePublished" datetime="2021-08-08T18:05:59+08:00">2021-08-08</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>1.1 JavaScript的组成</p>
<p>JavaScript 由 ECMAScript（JavaScript语法）、DOM（页面文档对象模型）和BOM（浏览器对象模型）组成，Web APIs是JS的应用，主要是指DOM和BOM</p>
<p>1.2 API</p>
<p>API（应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p>
<p>1.3 Web API</p>
<p>Web API 是浏览器提供的一套浏览器功能和页面元素的API（BOM和DOM），主要针对于浏览器做交互效果。</p>
<p><strong>Web API一般都有输入和输出（函数的传参和返回值），Web API很多都是方法（函数）。</strong></p>
<h3 id="二、DOM操作（增删改查、属性操作、事件操作）"><a href="#二、DOM操作（增删改查、属性操作、事件操作）" class="headerlink" title="二、DOM操作（增删改查、属性操作、事件操作）"></a>二、DOM操作（增删改查、属性操作、事件操作）</h3><p>文档对象模型，简称DOM，是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。</p>
<p>2.1 DOM树</p>
<ul>
<li><p>文档：一个页面就是一个文档，DOM中使用document表示</p>
</li>
<li><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p>
</li>
<li><p>节点：网页中的所有内容都说节点（标签、属性、文本、注释等），DOM中使用node表示</p>
<p><strong>DOM把以上内容都看作是对象</strong></p>
</li>
</ul>
<p>2.2 获取元素的方法</p>
<ul>
<li>var element = document.getElementById(‘ id名 ‘)     返回一个匹配到ID的DOM element对象，若没找到，则返回null</li>
<li>var element = document.getElementByTag(‘ 标签名 ‘)    返回带有指定标签名的对象的集合，<strong>得到的元素对象是动态的</strong>，若没找到，则返回空的集合（伪数组）。</li>
<li>var element = document.getElementByClassName(‘ 类名 ‘)      返回指定类名的对象的集合</li>
<li>var element = document.querySelector(‘ 选择器 ’)     返回指定选择器的第一个元素对象（<strong>id用 #   类名用 . </strong> ）</li>
<li>var element = document.querySelectorAll(‘ 选择器 ’)     返回指定选择器的所有元素对象的集合</li>
<li>var element = document.body     获取body元素对象集合</li>
<li>var element = document.documentElement      获取html元素对象集合</li>
</ul>
<p>2.3 事件基础</p>
<p>事件三要素：事件源、事件类型、事件处理程序</p>
<ul>
<li>事件源：事件被出发的对象（谁）</li>
<li>事件类型：如何触发    什么事件（鼠标点击、经过/键盘等）</li>
<li>事件处理程序：触发后做什么    通过一个函数赋值的方式完成</li>
</ul>
<p><strong>执行事件的步骤：</strong></p>
<ol>
<li><p><strong>获取事件源</strong></p>
</li>
<li><p><strong>注册事件（绑定事件）</strong></p>
</li>
<li><p><strong>添加事件处理程序（采取函数赋值形式）</strong></p>
<p>​                                                 常见鼠标事件</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">鼠标事件</th>
<th style="text-align:center">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onclick</td>
<td style="text-align:center">鼠标点击左键触发</td>
</tr>
<tr>
<td style="text-align:center">onmouseover</td>
<td style="text-align:center">鼠标经过触发</td>
</tr>
<tr>
<td style="text-align:center">onmouseout</td>
<td style="text-align:center">鼠标离开触发</td>
</tr>
<tr>
<td style="text-align:center">onfocus</td>
<td style="text-align:center">获得鼠标焦点触发</td>
</tr>
<tr>
<td style="text-align:center">onblur</td>
<td style="text-align:center">失去鼠标焦点触发</td>
</tr>
<tr>
<td style="text-align:center">onmousemove</td>
<td style="text-align:center">鼠标移动触发</td>
</tr>
<tr>
<td style="text-align:center">onmouseup</td>
<td style="text-align:center">鼠标左键弹起触发</td>
</tr>
<tr>
<td style="text-align:center">onmousedown</td>
<td style="text-align:center">鼠标按下触发</td>
</tr>
<tr>
<td style="text-align:center">contextmenu</td>
<td style="text-align:center">禁用右键菜单</td>
</tr>
<tr>
<td style="text-align:center">selectstart</td>
<td style="text-align:center">禁止选中文字</td>
</tr>
</tbody>
</table>
<p>2.4 操作元素</p>
<ul>
<li>element.innerText = ‘ 内容 ‘          从起始位置到终止位置的内容，但它不识别html标签，同时空格和换行也会去掉</li>
<li>element.innerHTML = ‘ 内容 ‘       起始位置到终止位置的全部内容，识别html标签，同时保留空格和换行（W3C推荐使用）</li>
</ul>
<p><strong>这两个属性是可读写的，可以获取元素里面的内容，即 可以使用 console.log(标签名.innerText)   输出标签的所有内容</strong> </p>
<p>2.5 获取元素属性</p>
<p>（1）element.属性（可以获取元素内置属性）</p>
<ul>
<li>可以使用 元素.属性 的方式  获取或修改元素属性内容</li>
<li>操作表单元素的属性：type、value、checked、selected、disabled，用 元素.属性 来进行操作</li>
<li>element.style.属性    行内样式操作（权重较高，属性采取驼峰命名法）</li>
<li>element.className    类名样式操作</li>
</ul>
<p>（2）element.getAttribute( ‘ 属性 ‘ )    （主要用于获得自定义的属性值）</p>
<p>（3）element.dataset.属性名   （dataset是一个集合，里面存放了所有以data-开头的自定义属性），如果属性名有多个 - ，要用驼峰命名法，如 data-list-name   =&gt;   element.dataset.listName</p>
<p>2.6 设置元素属性</p>
<p>（1）element.属性 = “ 值 ”</p>
<p>（2）element.setAttribute( ‘ 属性 ‘, ‘ 值 ‘ )    （主要针对自定义属性），H5中规定自定义属性要以<strong>data- 开头</strong>做完属性名并且赋值。</p>
<p><strong>class 比较特殊，如果element.setAttribute( ‘ class ‘, ‘ footer ‘ )  ; 这里面写的就是class，而不是className。</strong></p>
<p>（3）element.removeAttribute( ‘ 属性 ‘ )   移除属性</p>
<p>2.7 节点操作（利用节点层次关系获取节点）</p>
<ul>
<li>nodeName（节点类型）</li>
<li>nodeType（节点名称）<ul>
<li>元素节点 nodeType 为1</li>
<li>属性节点 nodeType 为2</li>
<li>文本节点 nodeType 为3（包括空格和换行）</li>
</ul>
</li>
<li>nodeValue（节点值）</li>
</ul>
<p>（1）父级节点</p>
<p>node.parentNode，返回某节点的最近的一个父节点，若没有则返回null</p>
<p>（2）子节点</p>
<ul>
<li style="list-style: none"><input type="checkbox"> parentNode.childNodes，返回包含指定节点的子节点的集合，该集合为即时更新的集合</li>
</ul>
<p><strong>注：返回值中包含了所有子节点，即包含元素节点，文本节点等。若只想获取里面的元素节点，需要通过nodeType==1进行判断筛选。</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox"> parentNode.children，是一个只读属性，只返回子元素节点集合，其余不返回</li>
<li style="list-style: none"><input type="checkbox"> parentNode.firstChild，返回第一个子节点，同样包含所有节点</li>
<li style="list-style: none"><input type="checkbox"> parentNode.lastChild，返回最后一个子节点，同样包含所有节点</li>
<li style="list-style: none"><input type="checkbox"> parentNode.fitstElementChild，返回第一个子元素节点，IE9以上才支持</li>
<li style="list-style: none"><input type="checkbox"> parentNode.lastElementChild，返回最后一个子元素节点，IE9以上才支持</li>
</ul>
<p>（3）兄弟节点</p>
<ul>
<li style="list-style: none"><input type="checkbox"> node.nextSibling，返回当前元素的下一个兄弟节点，包含元素节点和文本节点等，若没找到，返回null</li>
<li style="list-style: none"><input type="checkbox"> node.previousSibling，返回当前元素的上一个兄弟节点，包含元素节点和文本节点等，若没找到，返回null</li>
<li style="list-style: none"><input type="checkbox"> node.nextElementSibling，返回当前元素的下一个兄弟元素节点，找不到返回null，IE9以上才支持</li>
<li style="list-style: none"><input type="checkbox"> node.previousElementSibling，返回当前元素的上一个兄弟元素节点，找不到返回null，IE9以上才支持</li>
</ul>
<p><strong>兼容性问题怎么解决：封装一个兼容性函数，代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextElementSibling</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> el = element;</span><br><span class="line">    <span class="keyword">while</span>(el = el.nextSibling)&#123;</span><br><span class="line">        <span class="keyword">if</span>(el.nodeType === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> el;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）创建节点</p>
<ul>
<li style="list-style: none"><input type="checkbox"> document.createElement(‘tagName’)，创建由tagName指定的HTML元素，因为这些元素原先不存在，是根据我们需求动态生成的，所有也称为<strong>动态创建元素节点</strong>，创建多个元素效率稍低一点点，但是结构更清晰</li>
<li style="list-style: none"><input type="checkbox"> document.write(‘内容’)，是直接将内容写入页面的内容流，<strong>但是文档流执行完毕，则它会导致页面全部重绘，例如：当实现一个点击生成div的按钮功能时，当按钮出现（文档流执行完毕），然后点击按钮后，会重新创建一个新的页面，导致按钮消失（这就是页面重绘）</strong></li>
<li style="list-style: none"><input type="checkbox"> element.innerHTML = “内容”，是将内容写入某个DOM节点，不会导致页面全部重绘，<strong>在创建多个元素效率更高（不要采用拼接字符串的方式[很慢]，采用数组形式拼接），结构稍微复杂</strong></li>
</ul>
<p><strong>数组形式拼接：即先创建一个数组，然后通过push方法将内容添加到数组中，再通过数组.join(‘’)方法将数组转化为字符串的形式，在调用innerHTML方法添加到节点中。这种方法效率高，但是结构稍微复杂。</strong></p>
<p>（5）添加节点</p>
<ul>
<li style="list-style: none"><input type="checkbox"> node.appendChild(child)，将一个节点添加到指定父节点的子节点列表末尾，类似css的after伪元素</li>
<li style="list-style: none"><input type="checkbox"> node.insertBefore(child,指定元素)，将一个节点添加到父节点的指定子节点的前面，类似css的before伪元素</li>
</ul>
<p>（6）删除节点</p>
<p>node.removeChild(child)，从DOM中删除一个子节点，返回删除的节点</p>
<p>（7）复制节点（克隆节点/拷贝节点）</p>
<p>node.cloneNode()，返回调用该方法的节点的一个副本。</p>
<p><strong>注：如果括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点；   如果括号参数为true，则是深度拷贝，会复制节点本身以及里面的所有节点。</strong></p>
<h2 id="三、事件高级"><a href="#三、事件高级" class="headerlink" title="三、事件高级"></a>三、事件高级</h2><p>3.1 注册事件</p>
<p>（1）传统方式</p>
<ul>
<li><p>以on开头的事件。例onclick</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick = &quot; xxx &quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>btn.onclick = function(){}</p>
</li>
<li><p><strong>特点：注册事件的唯一性，即同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数会覆盖前面注册的处理函数</strong></p>
</li>
</ul>
<p>（2）方法监听注册方式</p>
<ul>
<li>w3c标准 推荐</li>
<li><p><em>eventTarget.addEventListener( type , listener [ , useCapture])，</em>将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数</p>
<ul>
<li>type：事件类型字符串，比如 click , mouseover , 注意这里不要带on</li>
<li>listener：事件处理函数，事件发生时，会调用该监听函数</li>
<li>useCapture：可选参数，是一个布尔值，默认是false。</li>
</ul>
</li>
<li><p>IE9之前，使用 <em>eventTarget.attachEvent(eventNameWithOn , callback)</em>代替，方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定事件时，指定的回调函数会被执行</p>
<ul>
<li>eventNameWithOn ：事件类型字符串，比如onclick,onmouseover，注意这个要带on</li>
<li>callback ：事件处理函数，当目标触发事件时回调函数被调用</li>
</ul>
</li>
<li><strong>特点：同一个元素同一个事件可以注册多个监听器</strong></li>
</ul>
<p>注册事件兼容性解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventListener</span>(<span class="params">element,eventName,fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前浏览器是否支持 addEventListener 方法</span></span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener)&#123;</span><br><span class="line">        element.addEventListener(eventName, fn);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123;</span><br><span class="line">        element.attachEvent(<span class="string">'on'</span>+ eventName, fn)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 相当于 element.onclick = fn;</span></span><br><span class="line">        element[<span class="string">'on'</span> + eventName] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>兼容性处理原则：首先照顾大多数浏览器，再处理特殊浏览器</strong></p>
<p>3.2 删除事件（解绑事件）</p>
<ul>
<li>element.onclick = null</li>
<li>eventTarget.removeEventListener(type , listener [ , useCapture])，listener为方法名称</li>
<li>eventTarget.detachEvent(eventNameWithOn , callback)，callback为方法名</li>
</ul>
<p>3.3 DOM事件流</p>
<p><strong>事件流描述的是从页面中接收事件的顺序</strong></p>
<p><strong>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</strong></p>
<p><strong>DOM事件流分为3个阶段：捕获阶段——&gt;当前目标阶段——&gt;冒泡阶段</strong></p>
<p>例如：给一个div注册了点击事件</p>
<p>首先是捕获节点，通过document——&gt;element html——&gt;element body——&gt;element div，即由DOM最顶层节点开始，然后逐级往下传播到最具体的元素接收的过程（网景最早提出），然后进入当前目标阶段，最后是冒泡阶段，通过element div——&gt;element body——&gt;element html——&gt;document到达最外层，即事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程（IE最早提出）</p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>JS代码中只能执行捕获或者冒泡其中的一个阶段</strong></li>
<li><strong>onclick 和 attachEvent 只能得到冒泡阶段</strong></li>
<li><strong>addEventListener( type , listener [ , useCapture]) 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false，表示在事件冒泡阶段调用事件处理程序</strong></li>
<li><strong>有些事件是没有冒泡的，比如 onblur ，obfocus，onmouseover，onmouseleave</strong></li>
</ul>
<p>3.4 事件对象</p>
<p>事件对象就是触发了一个事件以后，对该事件的一些描述信息，即与事件的一系列相关信息数据的集合</p>
<p>注册事件时event对象会被系统自动创建，并依次传递给事件监听器（事件处理函数），所以可以写到传统监听函数的参数中，当形参来看，并且可以自己命名，如event、evt、e等</p>
<p>兼容性问题，可以通过 e = e || window.event 来解决</p>
<p>​                                                事件对象的常见属性和方法</p>
<table>
<thead>
<tr>
<th>事件对象的属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>e.target</td>
<td>返回触发事件的对象（标准）</td>
</tr>
<tr>
<td>e.srcElement</td>
<td>返回触发事件的对象（非标准，IE6-8使用）</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型</td>
</tr>
<tr>
<td>e.cancelBubble</td>
<td>该属性阻止冒泡（非标准）</td>
</tr>
<tr>
<td>e.returnValue</td>
<td>该属性阻止默认事件（默认行为）非标准，比如不让链接跳转或让提交按钮不提交</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>该方法阻止默认事件（默认行为） 标准</td>
</tr>
<tr>
<td>e.stopPropagatation()</td>
<td>阻止冒泡（标准）</td>
</tr>
</tbody>
</table>
<p><strong>3.5 事件委托（代理、委派）</strong></p>
<p><strong>原理：不给每个子节点单独设置事件监听器，而且将事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</strong></p>
<p><strong>作用：减少DOM的使用次数，提高了程序的性能</strong></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">	ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 点击哪个li 就将那个li 的背景颜色修改为粉色</span></span><br><span class="line">        e.target.style.background = <span class="string">'pink'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.6 鼠标事件对象（MouseEvent）</p>
<ul>
<li><code>&quot;screenX&quot;</code>，<code>long</code> 型可选，默认为 <code>0</code>，设置鼠标事件发生时<strong>相对于用户屏幕</strong>的水平坐标位置；该操作并不会改变真实鼠标的位置。</li>
<li><code>&quot;screenY&quot;</code>，<code>long</code> 型可选，默认为 <code>0</code>，设置鼠标事件发生时<strong>相对于用户屏幕</strong>的垂直坐标位置；该操作并不会改变真实鼠标的位置。</li>
<li><code>&quot;clientX&quot;</code>，<code>long</code> 型可选，默认为 <code>0</code>，设置鼠标事件时<strong>相对于电脑屏幕</strong>的水平坐标位置；该操作并不会改变真实鼠标的位置。</li>
<li><code>&quot;clientY&quot;</code>，<code>long</code> 型可选，默认为 <code>0</code>，设置鼠标事件时<strong>相对于电脑屏幕</strong>的垂直坐标位置；该操作并不会改变真实鼠标的位置。</li>
<li><code>&quot;pageX&quot;</code>，<code>long</code> 型可选，默认为 <code>0</code>，设置鼠标事件时<strong>相对于文档页面</strong>的水平坐标位置；该操作并不会改变真实鼠标的位置。</li>
<li><code>&quot;pageY&quot;</code>，<code>long</code> 型可选，默认为 <code>0</code>，设置鼠标事件时<strong>相对于文档页面</strong>的垂直坐标位置；该操作并不会改变真实鼠标的位置。</li>
<li><code>&quot;ctrlKey&quot;</code>，<code>Boolean</code> 型可选，默认为<code>false</code>，标明是否同时按下 ctrl 键。</li>
<li><code>&quot;shiftKey&quot;</code>，<code>Boolean</code>型可选，默认为<code>false</code>，标明是否同时按下 shift 键。</li>
<li><code>&quot;altKey&quot;</code>，<code>Boolean</code> 型可选，默认为 <code>false</code>，标明是否同时按下 alt 键。</li>
<li><code>&quot;metaKey&quot;</code>，<code>Boolean</code> 型可选，默认为<code>false</code>，标明是否同时按下 meta 键。</li>
<li><code>&quot;button&quot;</code>，<code>short</code> 型可选型可选，默认为 <code>0</code>，描述了当事件发生时，哪个按键被按下或释放：0为左键被按下或未初始化、1为中键、2为右键</li>
<li><code>&quot;buttons&quot;</code>，无符号<code>short</code> 型可选型可选，默认为 <code>0</code>，描述了当事件发生时，哪个按键被按下或释放：0为无按键被按下、1为左键、2为右键、4为中键</li>
<li><code>&quot;relatedTarget&quot;</code>，<code>EventTarget</code> 型可选，默认为 <code>null</code>，若事件为 <code>mouseenter (en-US)</code> 或 <code>mouseover (en-US)</code>，则表示刚离开的元素；若事件为 <code>mouseout (en-US)</code> 或 <code>mouseleave (en-US)</code>，则表示刚进入的元素。</li>
<li><code>&quot;region&quot;</code>，<code>DOMString</code> 型可选，默认为<code>null</code>，标明点击事件影响的区域 DOM 的 id。不影响任何区域的话，请传<code>null</code>值。</li>
</ul>
<p>3.7 键盘事件和键盘事件对象（KeyboardEvent）</p>
<p>​                                                                键盘事件</p>
<table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>onkeyup</td>
<td>某个键盘按键被松开时触发</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被按下时触发</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键被按下时触发，但它不识别功能键（ctrl、shift、箭头等）</td>
</tr>
</tbody>
</table>
<p>三个事件的执行顺序：keydown——&gt;keypress——&gt;keyup</p>
<p><strong>注意：keydown和keypress在文本框内的特点：当事件触发的时候，文字还没有落入文本框中，而keyup事件触发时，文字已经落入文本框里面了</strong></p>
<p><strong>注：keyup和keydown不区分字符大小写，得到的keyCode属性是一样的，但keypress区分大小写</strong></p>
<p>键盘事件对象的属性方法</p>
<ul>
<li>KeyboardEvent.keyCode，返回该键的ASCII的值 </li>
<li>KeyboardEvent.altKey，如果alt键被按下则返回true，否则返回false</li>
<li>KeyboardEvent.code，返回触发事件的物理按键（这个属性会忽略用户键盘布局）</li>
<li>KeyboardEvent.ctrlKey，如果ctrl键被按下则返回true，否则返回false</li>
</ul>
<h2 id="四、BOM浏览器对象模型"><a href="#四、BOM浏览器对象模型" class="headerlink" title="四、BOM浏览器对象模型"></a>四、BOM浏览器对象模型</h2><p>4.1 BOM概述</p>
<p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window</p>
<p><strong>window对象是浏览器的顶级对象</strong>，它具有双重角色，既是JS访问浏览器窗口的一个接口，也是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。 </p>
<p><strong>注意：window下有一个特殊属性 window.name</strong></p>
<p>4.2 window常见事件</p>
<p>（1）窗口加载事件</p>
<ul>
<li>window.onload是窗口（页面）加载事件，当文档内容完全加载会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">	具体JS代码内容</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">window.addEventListener(&apos;load&apos;,function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。IE9以上才支持</li>
</ul>
<p>（2）窗口大小调整事件</p>
<ul>
<li>window.onresize  是调整窗口大小加载事件，当触发时就调用处理函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onresize = function()&#123;</span><br><span class="line">	具体JS代码内容</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">window.addEventListener(&apos;resize m&apos;,function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4.3 定时器</p>
<ul>
<li><p>window.setTimeout(调用函数，[延迟的毫秒数])，该方法用于设置一个定时器，该定时器在定时器到期后<strong>执行一次</strong>调用函数，这个调用函数也叫回调函数</p>
<p>注意：一是window在调用的时候可以省略，因此常常写 setTimeout()，二是调用函数可以直接写函数，或者写函数名，或者采取字符串 ‘ 函数名（）’这三种形式，但第三种不推荐</p>
</li>
<li><p>window.clearTimeout(timeoutID)，停止某个定时器</p>
</li>
<li><p>window.setInterval(调用函数，[间隔的毫秒数])，该方法<strong>重复调用</strong>一个函数，每隔这个时间，就去调用一次回调函数</p>
</li>
</ul>
<p>注意：同上setTimeout</p>
<p><strong>4.4 this的指向</strong></p>
<ul>
<li><p>全局作用域或者普通函数中的this指向全局对象window（注意定时器里面的this指向window）</p>
</li>
<li><p>方法调用中谁调用this指向谁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p = &#123;</span><br><span class="line">	sayHi:funtion()&#123;</span><br><span class="line">		console.log(this); // this指向的是 p 这个对象</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">o.sayHi();</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数中this指向构造函数的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Fun()&#123;</span><br><span class="line">	console.log(this);   // this 指向的是fun实例对象</span><br><span class="line">&#125;</span><br><span class="line">var fun = new Fun();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>this的指向在函数定义的时候是无法确认的，只有在函数执行的时候才能确定this到底指向谁，一般情况下，谁调用函数，this就指向谁</strong></p>
<p><strong>4.5 JS的执行机制</strong></p>
<p>JS是<strong>单线程</strong>的，即在<strong>同一个时间只能做一件事情</strong>，这样可能会导致一个问题：如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p>为了解决这个问题，利用多核CPU的计算能力，HTML5提出    Web Worker标准，允许JavaScript脚本创建多个线程，因此JS将任务分为了同步任务和异步任务。</p>
<p>同步是指前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p>
<p>（2）异步</p>
<p>异步则是可以同时执行多个任务。</p>
<p>（3）同步任务和异步任务</p>
<p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，会形成一个<strong>执行栈</strong>，</p>
<p>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>一般而言，异步任务有三种类型：普通事件（如：click、resize等），资源加载（如：load、error等），定时器（包括setInterval、setTimeout等）</p>
<p>（4）执行机制</p>
<ol>
<li>首先执行同步任务，所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。而那些对应的异步任务，就会结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p><strong>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop）</strong></p>
<p>4.7 location对象</p>
<p>（1）window对象提供了一个<strong>location属性</strong>用于<strong>获取或设置窗体的URL</strong>，并且可以用于<strong>解析URL</strong>。因为这个属性返回得是一个对象，所以我们也将这个属性称为<strong>location对象</strong>。</p>
<p>（2）URL（统一资源定位符）</p>
<p>URL的一般语法为：</p>
<p><code>protocol://host[:port]/path/[?query]#fragment</code></p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocol</td>
<td>通信协议，常用的http,ftp,maito等</td>
</tr>
<tr>
<td>host</td>
<td>主机（域名）<a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a></td>
</tr>
<tr>
<td>port</td>
<td>端口号，可选，省略时使用方案的默认端口</td>
</tr>
<tr>
<td>path</td>
<td>路径，表示主机上的一个目录或文件地址</td>
</tr>
<tr>
<td>query</td>
<td>参数，以键值对的形式，通过&amp;符号分隔开</td>
</tr>
<tr>
<td>fragment</td>
<td>片段，#后面内容，常见于链接、锚点</td>
</tr>
</tbody>
</table>
<p>（3）location对象的属性</p>
<table>
<thead>
<tr>
<th>location对象属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>location.href</td>
<td>获取或者设置整个URL</td>
</tr>
<tr>
<td>location.host</td>
<td>返回主线（域名）</td>
</tr>
<tr>
<td>location.port</td>
<td>返回端口号，如果未写则返回字符串</td>
</tr>
<tr>
<td>location.pathname</td>
<td>返回路径</td>
</tr>
<tr>
<td>location.search</td>
<td>返回参数</td>
</tr>
<tr>
<td>location.hash</td>
<td>返回片段，#后面内容</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>location对象方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>location.assign()</td>
<td>跟href一样，可以跳转页面，可以后退（也称为重定向页面）</td>
</tr>
<tr>
<td>location.replace()</td>
<td>替换当前页面，因为不记录历史，所以不能后退页面</td>
</tr>
<tr>
<td>location.reload()</td>
<td>重新加载页面，相当于刷新页面，如果参数为true，则是强制刷新</td>
</tr>
</tbody>
</table>
<p>4.8 navigator对象</p>
<p>navigator对象包含有关浏览器的信息，它有很多属性，最常用的是userAgent属性，该属性可以返回由客户机发送服务器的user-agent头部的值</p>
<p>4.9 history对象</p>
<p>window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p>
<table>
<thead>
<tr>
<th>history对象方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>back()</td>
<td>后退功能</td>
</tr>
<tr>
<td>forward()</td>
<td>前进功能</td>
</tr>
<tr>
<td>go(参数)</td>
<td>前进后退功能，参数如果是1，则前进一个页面，如果是-1，则后退一个页面</td>
</tr>
</tbody>
</table>
<h2 id="五、PC端网页特效"><a href="#五、PC端网页特效" class="headerlink" title="五、PC端网页特效"></a>五、PC端网页特效</h2><p>5.1 元素偏移量offset系列</p>
<p>offset系列相关属性可以<strong>动态的</strong>得到元素的位置（偏移）、大小等</p>
<ul>
<li><p>获得元素距离带有定位父元素的位置</p>
</li>
<li><p>获得元素自身的大小（宽高）</p>
</li>
<li><p>注意：返回的数值都不带单位</p>
<p>​                        offset常用属性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>offset常用属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.offsetParent</td>
<td>返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body</td>
</tr>
<tr>
<td>elemeny.offsetTop</td>
<td>返回元素相对带有定位父元素上方的偏移</td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>返回元素相对带有定位父元素左边框的偏移</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>返回自身包括padding、边框、内容区的宽度，返回数值不带单位</td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>返回自身包括padding、边框、内容区的高度，返回数值不带单位</td>
</tr>
</tbody>
</table>
<p>offset和style的区别</p>
<table>
<thead>
<tr>
<th>offset</th>
<th>style</th>
</tr>
</thead>
<tbody>
<tr>
<td>offset可以得到任意样式表中的样式值</td>
<td>style只能得到行内样式表中的样式值</td>
</tr>
<tr>
<td>offset系列获得的数值是没有单位的</td>
<td>style.width获得的是带有单位的字符串</td>
</tr>
<tr>
<td>offsetWidth包含padding+border+width</td>
<td>style.width不包含padding和border的值</td>
</tr>
<tr>
<td>offsetWidth等属性是只读属性，只能获取不能赋值</td>
<td>style.width是可读写属性，可以获取也可以赋值</td>
</tr>
<tr>
<td>所以，想要获取元素大小位置，用offset更合适</td>
<td>所以，想要给元素更改值，则需要用style改变</td>
</tr>
</tbody>
</table>
<p>5.2 元素可视区client系列</p>
<table>
<thead>
<tr>
<th>client系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.clientTop</td>
<td>返回元素上边框的大小</td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>返回元素左边框的大小</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
</tbody>
</table>
<p>5.3 元素滚动scroll系列</p>
<table>
<thead>
<tr>
<th>scroll系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.scrollTop</td>
<td>返回被卷去的上侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>返回被卷去的左侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身实际的（内容）宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>返回自身实际的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody>
</table>
<p>当盒子里面内容很多，scrollHeight为里面内容的总高度，scrollTop为滚动条脱到最下面时，盒子上沿和内容最上沿的距离。</p>
<p>当浏览器的高（宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，就是<strong>页面被卷去的头部</strong>。</p>
<p>滚动条在滚动时会触发onscroll事件</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>offset系列经常用于获得元素位置 offsetLeft、offsetTop</strong></li>
<li><strong>client系列经常用于获取元素的大小  clientWidth、clientHeight</strong></li>
<li><strong>scroll系列经常用于获取滚动距离   scrollTop、scrollLeft</strong></li>
</ul>
<p><strong>注：页面滚动的距离通过window.pageXoffset（window.pageYoffset）获得</strong></p>
<p><strong>mouseenter（mouseleave）和mouseover（mouseout）的区别：mouseenter（mouseleave）不会冒泡，而mouseover（mouseout）会冒泡，即mouseenter在鼠标经过（离开）自身盒子会触发，同时经过（离开）子盒子也会触发；mouseenter只有在经过（离开 ）自身盒子时才触发</strong></p>
<p>5.4 动画函数</p>
<p><strong>核心原理：通过定时器setInterval()不断移动盒子位置</strong></p>
<p>实现步骤：</p>
<p>1.获取盒子当前位置</p>
<p>2.让盒子在当前位置加上1个移动距离</p>
<p>3.利用定时器不断重复这个过程</p>
<p>4.加一个结束定时器的条件</p>
<p>注：此元素需要添加定位，才能使用element.style.left</p>
<p>节流阀：防止轮播按钮连续点击造成播放过快</p>
<p>目的：当上一个函数动画执行完毕，再去执行下一个函数动画，让事件无法连续触发 </p>
<p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数</p>
<h2 id="六、移动端网页特性"><a href="#六、移动端网页特性" class="headerlink" title="六、移动端网页特性"></a>六、移动端网页特性</h2><p>6.1 触屏事件（touch）</p>
<table>
<thead>
<tr>
<th>触屏touch事件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>touchstart</td>
<td>手指触摸到一个DOM元素时触发</td>
</tr>
<tr>
<td>touchmove</td>
<td>手指在一个DOM元素上滑动时触发</td>
</tr>
<tr>
<td>touchend</td>
<td>手指从一个DOM元素上移开时触发</td>
</tr>
</tbody>
</table>
<p>触摸事件对象（TouchEvent）</p>
<p>TouchEvent是一类描述手指在触摸屏幕的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，增加和减少等等</p>
<p>touchstart、touchmove、touchend三个事件都会有各自的事件对象。</p>
<table>
<thead>
<tr>
<th>触摸列表</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>touches</td>
<td>正在触摸屏幕的所有手指的一个列表</td>
</tr>
<tr>
<td>targetTouches</td>
<td>正在触摸当前DOM元素上的手指的一个列表</td>
</tr>
<tr>
<td>changedTouches</td>
<td>手指状态发生了改变的列表，从无到有，从有到无的变化</td>
</tr>
</tbody>
</table>
<p>6.2 移动端常见特性</p>
<p>（1）拖动元素三部曲</p>
<p>触摸元素touchstart：获取手指初始坐标，同时获得盒子原来得位置。通过e.targetTouches[0]里面的pageX和pageY得到当前手指坐标值；然后通过offsetLeft和offsetTop获得当前元素的位置</p>
<p>移动手指touchmove：计算手指的滑动距离（<em>e</em>.targetTouches[0]的X和Y减去手指初始位置），并且移动盒子（盒子初始位置加上手指滑动距离）</p>
<p>离开手指touchend：</p>
<p><strong>注：手指移动也会触发滚动屏幕，所有这里要阻止默认的屏幕滚动<em>e</em>.preventDefault()</strong></p>
<p>（2）classList，返回元素的类名数组</p>
<p>该元素用于在元素中添加，移除及切换CSS类，有以下方法：</p>
<p>添加类：element.classList.add(‘ 类名 ‘)，这个方法会在原来的类名后面追加类名，而className则会覆盖掉原有的类名，注意前面不需要加小点（.）</p>
<p>删除类：element.classList.remove(‘ 类名 ‘)</p>
<p>切换类：element.classList.toggle(‘ 类名 ‘)，如果classList 中<strong>有这个类就去掉，没有就添加</strong></p>
<p>（3）click延时解决方案</p>
<p>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放页面。</p>
<p>解决方案：</p>
<p>​    1.禁止缩放。浏览器禁止默认的双击缩放行为并且去掉300ms的点击延迟</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;user-sclable=no&quot;&gt;</code></p>
<p>​    2.利用touch事件封装一个事件解决300ms延迟</p>
<p>​        原理：首先当手指触摸屏幕时，记录当前触摸时间，然后当手指离开屏幕时，用离开的时间减去初始触摸时间，如果时间小于150ms，并且没有滑动屏幕，那么就将其定义为点击</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap</span>(<span class="params">obj,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isMove = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="number">0</span>;</span><br><span class="line">      obj.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;);</span><br><span class="line">   	  obj.addEventListener(<span class="string">'touchmove'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        isMove = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj.addEventListener(<span class="string">'touchend'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isMove &amp;&amp; (<span class="built_in">Date</span>.now() - startTime) &lt; <span class="number">150</span>)&#123;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;</span><br><span class="line">        isMove = <span class="literal">false</span>;</span><br><span class="line">        startTime =<span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">tap(div,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// 执行代码   </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​    3.利用fastclick插件解决</p>
<p>6.3 移动端常用开发插件</p>
<p>（1）JS插件就是JS文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。</p>
<p>特点：一般是为了解决某个问题而专门存在，其功能单一，且比较小</p>
<p>使用方法：首先引用插件相关文件，然后按照规定语法使用。</p>
<p>（2）fastclick插件</p>
<p>（3）swiper插件</p>
<p>（4）superslide插件</p>
<p>（5）iscroll插件</p>
<p>6.4 移动端常用开发框架</p>
<p>框架：大而全，一整套解决方案</p>
<h2 id="七、本地存储"><a href="#七、本地存储" class="headerlink" title="七、本地存储"></a>七、本地存储</h2><p>（1）本地存储特性</p>
<ul>
<li>数据存储在用户浏览器中</li>
<li>设置、读取方便，甚至页面刷新不丢失数据</li>
<li>容量较大，sessionStorage约5M、localStorage约20M</li>
<li>只能存储字符串，可以将对象JSON.string()编码后存储</li>
</ul>
<p>（2）sessionStorage</p>
<ul>
<li>生命周期为关闭浏览器窗口</li>
<li>在同一个窗口（页面）下数据可以共享</li>
<li>以键值对的形式存储使用</li>
</ul>
<p>存储数据：</p>
<p><code>sessionStorage.setItem(key,value)</code></p>
<p>获取数据：</p>
<p><code>sessionStorage.getItem(key)</code></p>
<p>删除数据：</p>
<p><code>sessionStorage.removeItem(key)</code></p>
<p>清空数据：</p>
<p><code>sessionStorage.clear()</code></p>
<p>（3）localStorage</p>
<ul>
<li>生命周期永久生效，除非手动JS删除或者清除浏览器缓存，否则关闭页面也会存在</li>
<li>可以多窗口（页面）共享（同一浏览器可以共享）</li>
<li>以键值对的形式存储使用</li>
</ul>
<p>存储数据：</p>
<p><code>localStorage.setItem(key,value)</code></p>
<p>获取数据：</p>
<p><code>localStorage.getItem(key)</code></p>
<p>删除数据：</p>
<p><code>localStorage.removeItem(key)</code></p>
<p>清空数据：</p>
<p><code>localStorage.clear()</code></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/28/移动web开发/" rel="next" title="移动web开发">
                <i class="fa fa-chevron-left"></i> 移动web开发
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、前言"><span class="nav-number">1.</span> <span class="nav-text">一、前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二、DOM操作（增删改查、属性操作、事件操作）"><span class="nav-number">1.1.</span> <span class="nav-text">二、DOM操作（增删改查、属性操作、事件操作）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、事件高级"><span class="nav-number">2.</span> <span class="nav-text">三、事件高级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、BOM浏览器对象模型"><span class="nav-number">3.</span> <span class="nav-text">四、BOM浏览器对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、PC端网页特效"><span class="nav-number">4.</span> <span class="nav-text">五、PC端网页特效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、移动端网页特性"><span class="nav-number">5.</span> <span class="nav-text">六、移动端网页特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、本地存储"><span class="nav-number">6.</span> <span class="nav-text">七、本地存储</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
